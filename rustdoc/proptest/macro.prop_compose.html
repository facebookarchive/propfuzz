<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `prop_compose` macro in crate `proptest`."><meta name="keywords" content="rust, rustlang, rust-lang, prop_compose"><title>proptest::prop_compose - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc macro"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../proptest/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class="location"><a href="index.html">proptest</a></p><script>window.sidebarCurrent = {name: "prop_compose", ty: "macro", relpath: ""};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/proptest/sugar.rs.html#607-685" title="goto source code">[src]</a></span><span class="in-band">Macro <a href="index.html">proptest</a>::<wbr><a class="macro" href="">prop_compose</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><div class="example-wrap"><pre class="rust macro">
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">prop_compose</span> {
    ($(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">meta</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
     <span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>:<span class="ident">vis</span>
     $([$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">modi</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>])<span class="question-mark">?</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">name</span>:<span class="ident">ident</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">params</span>:<span class="ident">tt</span>
     ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">var</span>:<span class="ident">pat</span> <span class="kw">in</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">strategy</span>:<span class="ident">expr</span>),<span class="op">+</span> $(,)<span class="question-mark">?</span>)
       <span class="op">-</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">return_type</span>:<span class="ident">ty</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">block</span>) <span class="op">=</span><span class="op">&gt;</span> { ... };
    ($(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">meta</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
     <span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>:<span class="ident">vis</span>
     $([$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">modi</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>])<span class="question-mark">?</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">name</span>:<span class="ident">ident</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">params</span>:<span class="ident">tt</span>
     ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">var</span>:<span class="ident">pat</span> <span class="kw">in</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">strategy</span>:<span class="ident">expr</span>),<span class="op">+</span> $(,)<span class="question-mark">?</span>)
     ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">var2</span>:<span class="ident">pat</span> <span class="kw">in</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">strategy2</span>:<span class="ident">expr</span>),<span class="op">+</span> $(,)<span class="question-mark">?</span>)
       <span class="op">-</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">return_type</span>:<span class="ident">ty</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">block</span>) <span class="op">=</span><span class="op">&gt;</span> { ... };
    ($(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">meta</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
     <span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>:<span class="ident">vis</span>
     $([$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">modi</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>])<span class="question-mark">?</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">name</span>:<span class="ident">ident</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">params</span>:<span class="ident">tt</span>
     ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg</span>:<span class="ident">tt</span>)<span class="op">+</span>)
       <span class="op">-</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">return_type</span>:<span class="ident">ty</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">block</span>) <span class="op">=</span><span class="op">&gt;</span> { ... };
    ($(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">meta</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
     <span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>:<span class="ident">vis</span>
     $([$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">modi</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>])<span class="question-mark">?</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">name</span>:<span class="ident">ident</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">params</span>:<span class="ident">tt</span>
     ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg</span>:<span class="ident">tt</span>)<span class="op">+</span> $(,)<span class="question-mark">?</span>)
     ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg2</span>:<span class="ident">tt</span>)<span class="op">+</span> $(,)<span class="question-mark">?</span>)
       <span class="op">-</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">return_type</span>:<span class="ident">ty</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">block</span>) <span class="op">=</span><span class="op">&gt;</span> { ... };
}</pre></div>
</div><div class="docblock"><p>Convenience to define functions which produce new strategies.</p>
<p>The macro has two general forms. In the first, you define a function with
two argument lists. The first argument list uses the usual syntax and
becomes exactly the argument list of the defined function. The second
argument list uses the <code>in strategy</code> syntax as with <code>proptest!</code>, and is
used to generate the other inputs for the function. The second argument
list has access to all arguments in the first. The return type indicates
the type of value being generated; the final return type of the function is
<code>impl Strategy&lt;Value = $type&gt;</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">proptest</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
  <span class="ident">integer</span>: <span class="ident">u32</span>,
  <span class="ident">string</span>: <span class="ident">String</span>,
}

<span class="macro">prop_compose</span><span class="macro">!</span> {
  <span class="kw">fn</span> <span class="ident">my_struct_strategy</span>(<span class="ident">max_integer</span>: <span class="ident">u32</span>)
                       (<span class="ident">integer</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">max_integer</span>, <span class="ident">string</span> <span class="kw">in</span> <span class="string">&quot;.*&quot;</span>)
                       <span class="op">-</span><span class="op">&gt;</span> <span class="ident">MyStruct</span> {
    <span class="ident">MyStruct</span> { <span class="ident">integer</span>, <span class="ident">string</span> }
  }
}</pre></div>
<p>This form is simply sugar around making a tuple and then calling <code>prop_map</code>
on it. You can also use <code>arg: type</code> as in <code>proptest! { .. }</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="macro">prop_compose</span><span class="macro">!</span> {
  <span class="kw">fn</span> <span class="ident">my_struct_strategy</span>(<span class="ident">max_integer</span>: <span class="ident">u32</span>)
                       (<span class="ident">integer</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">max_integer</span>, <span class="ident">string</span>: <span class="ident">String</span>)
                       <span class="op">-</span><span class="op">&gt;</span> <span class="ident">MyStruct</span> {
    <span class="ident">MyStruct</span> { <span class="ident">integer</span>, <span class="ident">string</span> }
  }
}</pre></div>
<p>The second form is mostly the same, except that it takes <em>three</em> argument
lists. The third argument list can see all values in both prior, which
permits producing strategies based on other strategies.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">proptest</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">prop_compose</span><span class="macro">!</span> {
  <span class="kw">fn</span> <span class="ident">nearby_numbers</span>()(<span class="ident">centre</span> <span class="kw">in</span> <span class="op">-</span><span class="number">1000</span>..<span class="number">1000</span>)
                   (<span class="ident">a</span> <span class="kw">in</span> <span class="ident">centre</span><span class="op">-</span><span class="number">10</span>..<span class="ident">centre</span><span class="op">+</span><span class="number">10</span>,
                    <span class="ident">b</span> <span class="kw">in</span> <span class="ident">centre</span><span class="op">-</span><span class="number">10</span>..<span class="ident">centre</span><span class="op">+</span><span class="number">10</span>)
                   <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">i32</span>, <span class="ident">i32</span>) {
    (<span class="ident">a</span>, <span class="ident">b</span>)
  }
}</pre></div>
<p>However, the body of the function does <em>not</em> have access to the second
argument list. If the body needs access to those values, they must be
passed through explicitly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">proptest</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">prop_compose</span><span class="macro">!</span> {
  <span class="kw">fn</span> <span class="ident">vec_and_index</span>
    (<span class="ident">max_length</span>: <span class="ident">usize</span>)
    (<span class="ident">vec</span> <span class="kw">in</span> <span class="ident">prop</span>::<span class="ident">collection</span>::<span class="ident">vec</span>(<span class="number">1</span>..<span class="number">10</span>, <span class="number">1</span>..<span class="ident">max_length</span>))
    (<span class="ident">index</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="ident">vec</span> <span class="kw">in</span> <span class="ident">Just</span>(<span class="ident">vec</span>))
    <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">usize</span>)
  {
    (<span class="ident">vec</span>, <span class="ident">index</span>)
  }
}</pre></div>
<p>The second form is sugar around making a strategy tuple, calling
<code>prop_flat_map()</code>, then <code>prop_map()</code>.</p>
<p>To give the function any modifier which isn't a visibility modifier, put it
in brackets before the <code>fn</code> token but after any visibility modifier.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">proptest</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">prop_compose</span><span class="macro">!</span> {
  <span class="kw">pub</span>(<span class="kw">crate</span>) [<span class="kw">unsafe</span>] <span class="kw">fn</span> <span class="ident">pointer</span>()(<span class="ident">v</span> <span class="kw">in</span> <span class="ident">prop</span>::<span class="ident">num</span>::<span class="ident">usize</span>::<span class="ident">ANY</span>)
                                <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">*</span><span class="kw">const</span> () {
    <span class="ident">v</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> ()
  }
}</pre></div>
<h2 id="comparison-with-hypothesis-composite" class="section-header"><a href="#comparison-with-hypothesis-composite">Comparison with Hypothesis' <code>@composite</code></a></h2>
<p><code>prop_compose!</code> makes it easy to do a lot of things you can do with
<a href="https://hypothesis.readthedocs.io/en/latest/data.html#composite-strategies">Hypothesis' <code>@composite</code></a>,
but not everything.</p>
<ul>
<li>
<p>You can't filter via this macro. For filtering, you need to make the
strategy the &quot;normal&quot; way and use <code>prop_filter()</code>.</p>
</li>
<li>
<p>More than two layers of strategies or arbitrary logic between the two
layers. If you need either of these, you can achieve them by calling
<code>prop_flat_map()</code> by hand.</p>
</li>
</ul>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "proptest";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>